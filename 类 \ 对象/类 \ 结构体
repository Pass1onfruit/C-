
在C中struct是用来封装数据的，其中不能够有函数成员
而在C++中继承了在C语言中的用法，但是在struct中允许有成员函数，这时候的sturct可以进行class的任何语法操作，如构造函数，析构函数，重载运算符等

两者唯一的区别就是struct中的成员，变量默认存取权限，包括继承都是public的，class中是private

结构体也可以被认为是一种特殊的类，它不存在任何函数，构造和析构函数也没有，而且是一个默认公共的的类

结构体基本用在多数据时，需要一个结构体来封装这些数据
而类是面向对象的思想，可以有很多接口让人调用，私有变量等外部不能调用，还有保护类型的变量

类要加上public变成共有的才能被访问，而结构本身就是共有的可直接访问

C定义结构体变量时需要加struct关键字，C++中定义结构体变量时可以不加struct关键字

结构体内存对齐规： 
1. 第一个成员在与结构体偏移量为0的地址处
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
对齐数 = 编译器默认的一个 对齐数 与 该成员大小 的较小值，VS中默认的对齐数为8，gcc中的对齐数为4
3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍
如：
//32位环境下
struct Data
{
    char a;
    int b;
    long c;
    char d;
}

每一个结构体第一个成员的偏移量都为0
a的大小是1，也就是b的偏移量，b的大小是4，1不是4的倍数，所以a的大小1应该加上3，就是4
c的偏移量是8，c的大小是8，c的偏移量是成员c大小的倍数，就不用增加大小
d的偏移量是16，d的大小是1，偏移量是成员大小的倍数，还有另一条规则：结构体大小是结构体最大成员的倍数，最大成员为c，大小为8，结构体的大小为各个成员之和，所有的成员加起来是17，但17不是8的倍数，所以应该将17+7，所以该结构体的大小是24

类对象大小计算：
一个类的大小，实际就是该类中”成员变量”之和，和结构体一样，成员函数不会占用空间，同时也需要进行内存对齐
空类的大小比较特殊，编译器给了空类一个字节来唯一标识这个类

包含虚函数的类，对象生成时，会在类对象当中插入一个指针，这个指针称做虚函数表指针，简称虚表指针(vPtr)
该指针指向一个虚函数表(简称虚表)，虚函数表中存储了虚函数的入口地址
基类当中有虚函数时，会产生该虚函数表
创建基类对象，对象中的vPtr会指向该表
调用虚函数时，通过vPtr在此表当中寻找函数入口地址
所以当基类有虚函数时，会多出一个vptr的大小（4字节）

当派生类继承含有虚函数的子类时，会复制一份 虚函数表，派生类如果有与基类中虚函数同名的虚函数，会在虚函数表中覆盖原来基类的虚函数（多态）
如果虚函数不重名，只会在虚函数表中增加一个函数入口
当一个类继承了两个含虚函数的基类类，会复制两个虚函数表，所以会加8字节，如果其本身也含虚函数，会放在其中一个表中，不会再增加大小





