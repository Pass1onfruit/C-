

以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开

可以解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，没有函数压栈的开销， 内联函数提升程序运行的效率

1. inline是一种以空间换时间的做法，省去调用函数额开销，所以代码很长或者有 循环/递归 的函数不适宜使用作为内联函数
2. inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等等，编译器优化时会忽略掉内联

使用：
inline char* oddEven(int i) 
{
    return (i % 2 > 0) ? "奇" : "偶";
} 

在编译期间编译器会用函数体替换函数的调用
即在每个 for 循环的内部任何调用 oddEven(i) 的地方都换成了 (i%2>0)?"奇":"偶"，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗

inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）

类中的内联函数
class A
{
    public:void Foo(int x, int y) {  } // 自动地成为内联函数
}
定义在类中的成员函数默认都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的
// 头文件
class A
{
    public:
    void Foo(int x, int y);
}
// 定义文件
inline void A::Foo(int x, int y){}

关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面也不起任何作用

3. inline不建议声明和定义分离，分离会导致链接错误，因为inline被展开，就没有函数地址了，链接就会找不到

如：
// F.h
#include <iostream> 
using namespace std;

inline void f(int i);

// F.cpp 
#include "F.h" 
void f(int i)
{
	cout << i << endl;
}

// main.cpp #include "F.h"
int main()
{
	f(10);
	return 0;
}
 
// 链接错误：main.obj : error LNK2019: 无法解析的外部符号 "void __cdecl f(int)" (? f@@YAXH@Z)，该符号在函数 _main 中被引用

内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率
如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少
而每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间
如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大
所以内联函数不能增强性能时，就避免使用它
