int main()
{
CLASS s1; //生命周期在main函数中
s1.COUT(10);

CLASS(); //匿名对象//生命周期仅仅在这一行
CLASS().COUT(10); 
}

虚拟内存：进程地址空间（监视窗口看到的）
每个进程都分配实际的物理内存，不够大的
建立映射物理内存的一部分，要用的时候才建立映射
访问虚拟地址，访问过程中没有发生命中会触发缺页中断，通过通过页表可以算出映射的物理地址
MMU  《深入理解计算机系统》-虚拟内存
32位进程：2^32字节（4G）的虚拟内存
64位进程：2^64字节虚拟内存（科技进步，物理内存变得比虚拟内存还大了）

物理内存：
保守的资源，
栈和堆是最耗内存的

编写的代码是存在文件系统上的
编译器去读这个程序，通过编译链接生成二进制可执行程序a.out
./a.out在一个终端下去运行程序，运行程序a.out相当于终端创建了一个子进程，exec对创建的子进程进行替换，替换成a.out
a.out中的 代码指令 加载到 代码段
其中的 全局数据 加载到 数据段
然后建立main函数的栈帧，往下走
进行资源销毁，结束

C中的动态内存管理方式
malloc（函数）  申请空间
calloc  申请空间并初始化
realloc  堆原有空间扩容
free  释放空间
int* p1 = (int*) malloc (sizeof (int));
int* p3 = (int*)malloc (sizeof (int) *10);
free (p1);
free (p3);

C++：
new（操作符）
delete
int* p2= new int;
int* p2= new int (10):  //申请一个int4个字节空间,初始化成10
int*p4 = new int [10];  //申110个int的40个字节空间
delete p2;
delete [] p4:

new/delete申请和释放的是单个元素的空间，new[]/delete[]申请的是连续的空间

operator new 为new开空间，也可以拿出来单独使用
和 malloc用法功能一样
int* p2 = (int*) operator new(sizeof (int));
区别：使用方式一样，处理错误的方式不一样
malloc返回错误码；operator new抛bad_alloc异常

new 调用构造函数初始化，调operator new开空间，失败了抛异常
malloc和new 对于内置类型（基本类型）没有什么区别
对于自定义类型不一样。
malloc只申请空间；new申请空间+构造函数初始化
free只释放空间；delete调用析构函数清理+释放空间

内存泄漏：
C++独有的问题，相比之下Java就轻松很多，有打击回收器（new了对象后不用手动释放）

int main C
{
// 开1G空间
char* p= new char [1024*1024*1024]:
//内存泄漏：忘记或其他原因释放p指向的空间，就会内存泄漏
return 0;
}
危害：
以上的内存泄漏并没有体现出什么危害，在进程地址空间，进程只要正常结束，进程都会自动回收，资源都会释放，如果有映射的物理内存也会还给系统
对于长期运行的程序（比如后台服务），危害较大，或者设备的内存本身很小也有危害
使用完的内存不用了但是不释放，其他线程想用就用不上了，内存是有限的，进程就会越来越慢，甚至系统都会越来越慢


