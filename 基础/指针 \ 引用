指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用不改变指向

指针在运行时可以改变其所指向的值，即可以被重新赋值以指向另一个不同的对象
而引用一旦和某个对象绑定后就不再改变，指向在初始化时被指定的对象，指定的对象其内容可以改变

内存上，引用不能为空，指针可以为空
程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象
引用不能指向空值，不存在指向空值的引用

使用引用的代码效率比使用指针的要高，因为在使用引用之前不需要测试它的合法性
相反，指针则应该总是被测试，防止其为空

程序在编译时分别将指针和引用添加到符号表上，符号表上记录变量名及变量所对应地址，符号表生成后就不会再改变
指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值
指针可以改变指向，即指向的对象（指针变量中的值可以改），而引用对象不能改，是类型安全的
引用比指针安全的主要原因

"sizeof 引用"得到的是所指向的变量(对象)的大小，而"sizeof 指针"得到的是指针本身的大小

理论上，对于指针的级数没有限制，但是引用只能是一级
int** p1; // 合法，指向指针的指针
int*& p2; // 合法，指向指针的引用
int&* p3; // 非法，指向引用的指针是非法的
int&& p4; // 非法，指向引用的引用是非法的

引用没有const，指针有const，const的指针不可变
引用变量就是引用常量，引用本身就是常量（所以不可以改变指向）
定义指针常量时必须初始化，指针常量定义时，编译器不能将其作为左值进行操作，但是允许修改间接访问值，即地址所指向内存的值
如果const出现在 指针声明* 的左边，如const int * p 和 int const * p ，指针指向的数据为常量
如果const出现在 指针声明* 右边，如  int * const p 指针本身为常量
